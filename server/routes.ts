import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { setupAuth, isAuthenticated } from "./replitAuth";
import { db } from "./db";
import { eq } from "drizzle-orm";
import { conversations } from "@shared/schema";
import {
  insertAgentSchema,
  insertAssistantFollowSchema,
  insertWhisperSchema,
  insertSnipSchema,
  insertMessageSchema,
  insertInteractionSchema,
  insertNotificationSchema,
} from "@shared/schema";
import { processSnipResonance, getSnipResonances, findResonancePathways } from "./lib/resonanceEngine";

// AI Content Generation Functions
function generatePostContent(whisperContent: string, agent: any): string {
  return `ðŸŒŸ **Transforming Thoughts into Engaging Content**

Based on your whisper: "${whisperContent}"

Hi everyone! ðŸ‘‹ I wanted to share some thoughts that have been on my mind lately.

${whisperContent}

This got me thinking about how we can approach this topic from different angles. Here are some key insights:

â€¢ **Context Matters**: Every idea exists within a broader context that shapes its meaning and impact
â€¢ **Community Perspective**: What resonates with one person might spark entirely different thoughts in another
â€¢ **Continuous Evolution**: Our understanding of concepts grows and changes as we engage with them

What's your take on this? I'd love to hear your thoughts and experiences in the comments below! 

---
*Generated by ${agent.name} - Your AI content creation assistant*`;
}

function generateResearchContent(whisperContent: string, agent: any): string {
  return `ðŸ“š **Deep Research Analysis**

**Your Research Query**: "${whisperContent}"

**Comprehensive Analysis by ${agent.name}**

**Key Findings:**
1. **Primary Aspects**: The topic you've raised touches on several important dimensions that warrant deeper exploration
2. **Current Trends**: Based on available information, there are emerging patterns worth considering
3. **Potential Applications**: Several practical use cases and implications emerge from this research

**Detailed Breakdown:**
- **Background Context**: Understanding the foundational elements
- **Current State**: Where things stand today based on available data
- **Future Implications**: Potential developments and considerations
- **Actionable Insights**: Specific steps or considerations you might want to explore

**Research Methodology:**
This analysis combines pattern recognition, contextual understanding, and logical reasoning to provide comprehensive insights on your topic.

**Next Steps:**
Consider diving deeper into specific aspects that interest you most. Would you like me to explore any particular angle in more detail?

---
*Private research conducted by ${agent.name} | Confidential Analysis*`;
}

export async function registerRoutes(app: Express): Promise<Server> {
  // Auth middleware
  await setupAuth(app);

  // Auth routes
  app.get('/api/auth/user', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      // Check if user has a personal assistant, if not create one
      const existingAssistant = await storage.getUserAssistant(userId);
      if (!existingAssistant) {
        const userName = req.user.claims.first_name || req.user.claims.email?.split('@')[0] || 'User';
        await storage.createAgent({
          userId: userId,
          name: userName, // Use user's actual name as assistant name (digital twin)
          alias: `${userName.toLowerCase().replace(/\s+/g, '_')}_ai`,
          description: `${userName}'s digital intelligence companion. An AI assistant trained to understand and amplify your thoughts, ideas, and creative vision.`,
          expertise: 'Personal Digital Twin',
          personality: `A digital reflection of ${userName}'s intellectual approach - analytical, creative, and thoughtful. Specializes in transforming raw thoughts into polished content while maintaining authentic voice and perspective.`,
          avatar: 'from-blue-500 to-purple-600',
          isActive: true,
          isPersonalAssistant: true,
        });
      }
      
      res.json(user);
    } catch (error) {
      console.error("Error fetching user:", error);
      res.status(500).json({ message: "Failed to fetch user" });
    }
  });

  // Agent routes
  app.post('/api/agents', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const agentData = insertAgentSchema.parse({ ...req.body, userId });
      const agent = await storage.createAgent(agentData);
      res.json(agent);
    } catch (error) {
      console.error("Error creating agent:", error);
      res.status(400).json({ message: "Failed to create agent" });
    }
  });

  app.get('/api/agents', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const agents = await storage.getUserAgents(userId);
      res.json(agents);
    } catch (error) {
      console.error("Error fetching agents:", error);
      res.status(500).json({ message: "Failed to fetch agents" });
    }
  });

  app.get('/api/agents/check-alias', isAuthenticated, async (req: any, res) => {
    try {
      const { alias } = req.query;
      
      if (!alias || typeof alias !== 'string') {
        return res.status(400).json({ message: "Alias parameter required" });
      }

      const existingAgent = await storage.getAgentByAlias(alias);
      const available = !existingAgent;
      
      res.json({ available });
    } catch (error) {
      console.error("Error checking alias availability:", error);
      res.status(500).json({ message: "Failed to check alias availability" });
    }
  });

  app.get('/api/agents/:id', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const agent = await storage.getAgent(parseInt(req.params.id));
      if (!agent || agent.userId !== userId) {
        return res.status(404).json({ message: "Agent not found" });
      }
      res.json(agent);
    } catch (error) {
      console.error("Error fetching agent:", error);
      res.status(500).json({ message: "Failed to fetch agent" });
    }
  });

  app.get('/api/agents/:id/snips', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const agentId = parseInt(req.params.id);
      
      // Verify agent ownership
      const agent = await storage.getAgent(agentId);
      if (!agent || agent.userId !== userId) {
        return res.status(404).json({ message: "Agent not found" });
      }
      
      const snips = await storage.getAgentSnips(agentId);
      res.json(snips);
    } catch (error) {
      console.error("Error fetching agent snips:", error);
      res.status(500).json({ message: "Failed to fetch agent snips" });
    }
  });

  app.put('/api/agents/:id', isAuthenticated, async (req: any, res) => {
    try {
      const agentId = parseInt(req.params.id);
      const updates = req.body;
      const agent = await storage.updateAgent(agentId, updates);
      res.json(agent);
    } catch (error) {
      console.error("Error updating agent:", error);
      res.status(400).json({ message: "Failed to update agent" });
    }
  });

  app.delete('/api/agents/:id', isAuthenticated, async (req: any, res) => {
    try {
      const agentId = parseInt(req.params.id);
      await storage.deleteAgent(agentId);
      res.json({ message: "Agent deleted successfully" });
    } catch (error) {
      console.error("Error deleting agent:", error);
      res.status(500).json({ message: "Failed to delete agent" });
    }
  });

  // Get agent by alias (public endpoint)
  app.get('/api/agents/alias/:alias', async (req, res) => {
    try {
      const alias = req.params.alias;
      const agent = await storage.getAgentByAlias(alias);
      
      if (!agent) {
        return res.status(404).json({ message: 'Agent not found' });
      }
      
      res.json(agent);
    } catch (error) {
      console.error('Error fetching agent by alias:', error);
      res.status(500).json({ message: 'Failed to fetch agent' });
    }
  });

  // Get agent's public snips
  app.get('/api/agents/:id/snips/public', async (req, res) => {
    try {
      const agentId = parseInt(req.params.id);
      const snips = await storage.getAgentSnips(agentId, 20);
      res.json(snips);
    } catch (error) {
      console.error('Error fetching public agent snips:', error);
      res.status(500).json({ message: 'Failed to fetch agent snips' });
    }
  });

  // Whisper routes
  app.post('/api/whispers', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const whisperData = insertWhisperSchema.parse({ ...req.body, userId });
      const whisper = await storage.createWhisper(whisperData);

      // Process whisper based on type
      setTimeout(async () => {
        try {
          await storage.updateWhisperStatus(whisper.id, 'processing');
          
          const agent = await storage.getAgent(whisper.agentId!);
          if (agent) {
            let processedContent = '';
            let title = '';
            let excerpt = '';
            let shouldCreateSnip = false;

            if (whisper.type === 'create-post') {
              // Create Post: Transform into engaging public content
              title = `Engaging Post by ${agent.name}`;
              excerpt = 'AI-crafted content for public sharing';
              processedContent = generatePostContent(whisper.content, agent);
              shouldCreateSnip = true;
            } else if (whisper.type === 'do-research') {
              // Do Research: Private processing with research capabilities
              title = `Research Results by ${agent.name}`;
              excerpt = 'Private research and analysis';
              processedContent = generateResearchContent(whisper.content, agent);
              shouldCreateSnip = false; // Keep private for research
            } else {
              // Legacy support for old whisper types
              title = `Generated content from ${agent.name}`;
              excerpt = `AI response from ${agent.name}`;
              processedContent = `This is AI-generated content based on your whisper: "${whisper.content}". The agent ${agent.name} with expertise in ${agent.expertise} has processed your input and created this comprehensive response.`;
              shouldCreateSnip = true;
            }

            // Create snip only for public content
            if (shouldCreateSnip) {
              const snipData = {
                whisperId: whisper.id,
                assistantId: whisper.agentId!,
                userId,
                title,
                content: processedContent,
                excerpt,
                type: 'article' as const,
                tags: JSON.stringify([agent.expertise]),
              };

              const snip = await storage.createSnip(snipData);
              
              // Process resonances for the new snip in the background
              processSnipResonance(snip.id).catch(error => {
                console.error(`Failed to process resonances for snip ${snip.id}:`, error);
              });
              
              // Notification for published snip
              await storage.createNotification({
                userId,
                type: 'snip_published',
                title: 'New Snip Published',
                content: `Your assistant has created a new public post from your whisper.`,
                metadata: { snipId: snip.id, agentId: agent.id },
              });
            } else {
              // Notification for private research
              await storage.createNotification({
                userId,
                type: 'whisper_processed',
                title: 'Research Complete',
                content: `Your assistant has completed the research on your topic.`,
                metadata: { whisperId: whisper.id, agentId: agent.id },
              });
            }

            await storage.updateWhisperStatus(whisper.id, 'processed', new Date());
          }
        } catch (error) {
          console.error("Error processing whisper:", error);
          await storage.updateWhisperStatus(whisper.id, 'failed');
        }
      }, 2000); // 2 second delay

      res.json(whisper);
    } catch (error) {
      console.error("Error creating whisper:", error);
      res.status(400).json({ message: "Failed to create whisper" });
    }
  });

  app.get('/api/whispers', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const limit = parseInt(req.query.limit as string) || 50;
      const whispers = await storage.getUserWhispers(userId, limit);
      res.json(whispers);
    } catch (error) {
      console.error("Error fetching whispers:", error);
      res.status(500).json({ message: "Failed to fetch whispers" });
    }
  });

  // Get specific whisper
  app.get('/api/whispers/:id', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const whisper = await storage.getWhisper(parseInt(req.params.id));
      if (!whisper) {
        return res.status(404).json({ message: 'Whisper not found' });
      }
      // Check if user owns this whisper
      if (whisper.userId !== userId) {
        return res.status(403).json({ message: 'Access denied' });
      }
      res.json(whisper);
    } catch (error) {
      console.error('Error fetching whisper:', error);
      res.status(500).json({ message: 'Failed to fetch whisper' });
    }
  });

  // Get snip generated from whisper
  app.get('/api/whispers/:id/snip', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const whisper = await storage.getWhisper(parseInt(req.params.id));
      if (!whisper) {
        return res.status(404).json({ message: 'Whisper not found' });
      }
      // Check if user owns this whisper
      if (whisper.userId !== userId) {
        return res.status(403).json({ message: 'Access denied' });
      }
      
      // Find snip generated from this whisper
      const snips = await storage.getUserSnips(userId);
      const snip = snips.find(s => s.whisperId === whisper.id);
      
      if (!snip) {
        return res.status(404).json({ message: 'No snip found for this whisper' });
      }
      
      res.json(snip);
    } catch (error) {
      console.error('Error fetching whisper snip:', error);
      res.status(500).json({ message: 'Failed to fetch whisper snip' });
    }
  });

  // Following system routes
  app.post('/api/assistants/:id/follow', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const followingId = parseInt(req.params.id);
      
      // Get user's own assistant
      const userAssistant = await storage.getUserAssistant(userId);
      if (!userAssistant) {
        return res.status(400).json({ message: "User assistant not found" });
      }
      
      // Don't allow following yourself
      if (userAssistant.id === followingId) {
        return res.status(400).json({ message: "Cannot follow yourself" });
      }
      
      await storage.followAssistant(userAssistant.id, followingId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error following assistant:", error);
      res.status(500).json({ message: "Failed to follow assistant" });
    }
  });

  app.delete('/api/assistants/:id/follow', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const followingId = parseInt(req.params.id);
      
      // Get user's own assistant
      const userAssistant = await storage.getUserAssistant(userId);
      if (!userAssistant) {
        return res.status(400).json({ message: "User assistant not found" });
      }
      
      await storage.unfollowAssistant(userAssistant.id, followingId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error unfollowing assistant:", error);
      res.status(500).json({ message: "Failed to unfollow assistant" });
    }
  });

  app.get('/api/assistants/:id/followers', async (req, res) => {
    try {
      const assistantId = parseInt(req.params.id);
      const followers = await storage.getAssistantFollowers(assistantId);
      res.json(followers);
    } catch (error) {
      console.error("Error fetching followers:", error);
      res.status(500).json({ message: "Failed to fetch followers" });
    }
  });

  app.get('/api/assistants/:id/following', async (req, res) => {
    try {
      const assistantId = parseInt(req.params.id);
      const following = await storage.getAssistantFollowing(assistantId);
      res.json(following);
    } catch (error) {
      console.error("Error fetching following:", error);
      res.status(500).json({ message: "Failed to fetch following" });
    }
  });

  app.get('/api/assistants/recommended', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const limit = parseInt(req.query.limit as string) || 10;
      const recommended = await storage.getRecommendedAssistants(userId, limit);
      res.json(recommended);
    } catch (error) {
      console.error("Error fetching recommended assistants:", error);
      res.status(500).json({ message: "Failed to fetch recommended assistants" });
    }
  });

  app.get('/api/assistants/:followerId/is-following/:followingId', async (req, res) => {
    try {
      const followerId = parseInt(req.params.followerId);
      const followingId = parseInt(req.params.followingId);
      const isFollowing = await storage.isFollowing(followerId, followingId);
      res.json({ isFollowing });
    } catch (error) {
      console.error("Error checking follow status:", error);
      res.status(500).json({ message: "Failed to check follow status" });
    }
  });

  // Search route
  app.get('/api/search', async (req, res) => {
    try {
      // The query parameter is the search term - it's passed as part of the URL params
      const queryParams = new URLSearchParams(req.url?.split('?')[1] || '');
      const query = queryParams.get('q') || req.query.q as string;
      
      if (!query || query.trim().length < 2) {
        return res.json({ snips: [], whispers: [] });
      }

      const [snips, whispers] = await Promise.all([
        storage.searchSnips(query.trim()),
        storage.searchWhispers(query.trim())
      ]);

      res.json({ snips, whispers });
    } catch (error) {
      console.error("Error performing search:", error);
      res.status(500).json({ message: "Failed to perform search" });
    }
  });

  // Resonance routes
  app.get('/api/snips/:id/resonances', async (req, res) => {
    try {
      const snipId = parseInt(req.params.id);
      const limit = parseInt(req.query.limit as string) || 10;
      const resonances = await getSnipResonances(snipId, limit);
      res.json(resonances);
    } catch (error) {
      console.error("Error fetching resonances:", error);
      res.status(500).json({ message: "Failed to fetch resonances" });
    }
  });

  app.get('/api/snips/:id/pathways', async (req, res) => {
    try {
      const snipId = parseInt(req.params.id);
      const depth = parseInt(req.query.depth as string) || 2;
      const pathways = await findResonancePathways(snipId, depth);
      res.json(pathways);
    } catch (error) {
      console.error("Error finding resonance pathways:", error);
      res.status(500).json({ message: "Failed to find resonance pathways" });
    }
  });

  app.post('/api/snips/:id/process-resonance', isAuthenticated, async (req: any, res) => {
    try {
      const snipId = parseInt(req.params.id);
      await processSnipResonance(snipId);
      res.json({ success: true, message: "Resonance processing completed" });
    } catch (error) {
      console.error("Error processing resonance:", error);
      res.status(500).json({ message: "Failed to process resonance" });
    }
  });

  // Mempod Knowledge routes
  app.get('/api/mempod/knowledge', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const knowledge = await storage.getMempodKnowledge(userId);
      res.json(knowledge);
    } catch (error) {
      console.error('Error fetching knowledge:', error);
      res.status(500).json({ error: 'Failed to fetch knowledge' });
    }
  });

  app.post('/api/mempod/knowledge', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const knowledge = await storage.createMempodKnowledge({
        ...req.body,
        userId
      });
      res.json(knowledge);
    } catch (error) {
      console.error('Error creating knowledge:', error);
      res.status(500).json({ error: 'Failed to create knowledge' });
    }
  });

  app.put('/api/mempod/knowledge/:id', isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const knowledge = await storage.updateMempodKnowledge(parseInt(id), req.body);
      res.json(knowledge);
    } catch (error) {
      console.error('Error updating knowledge:', error);
      res.status(500).json({ error: 'Failed to update knowledge' });
    }
  });

  app.delete('/api/mempod/knowledge/:id', isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      await storage.deleteMempodKnowledge(parseInt(id));
      res.json({ success: true });
    } catch (error) {
      console.error('Error deleting knowledge:', error);
      res.status(500).json({ error: 'Failed to delete knowledge' });
    }
  });

  // Mempod Notes routes
  app.get('/api/mempod/notes', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const notes = await storage.getMempodNotes(userId);
      res.json(notes);
    } catch (error) {
      console.error('Error fetching notes:', error);
      res.status(500).json({ error: 'Failed to fetch notes' });
    }
  });

  app.post('/api/mempod/notes', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const note = await storage.createMempodNote({
        ...req.body,
        userId
      });
      res.json(note);
    } catch (error) {
      console.error('Error creating note:', error);
      res.status(500).json({ error: 'Failed to create note' });
    }
  });

  app.put('/api/mempod/notes/:id', isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const note = await storage.updateMempodNote(parseInt(id), req.body);
      res.json(note);
    } catch (error) {
      console.error('Error updating note:', error);
      res.status(500).json({ error: 'Failed to update note' });
    }
  });

  app.delete('/api/mempod/notes/:id', isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      await storage.deleteMempodNote(parseInt(id));
      res.json({ success: true });
    } catch (error) {
      console.error('Error deleting note:', error);
      res.status(500).json({ error: 'Failed to delete note' });
    }
  });

  // Mempod Goals routes
  app.get('/api/mempod/goals', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const goals = await storage.getMempodGoals(userId);
      res.json(goals);
    } catch (error) {
      console.error('Error fetching goals:', error);
      res.status(500).json({ error: 'Failed to fetch goals' });
    }
  });

  app.post('/api/mempod/goals', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const goal = await storage.createMempodGoal({
        ...req.body,
        userId
      });
      res.json(goal);
    } catch (error) {
      console.error('Error creating goal:', error);
      res.status(500).json({ error: 'Failed to create goal' });
    }
  });

  app.put('/api/mempod/goals/:id', isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const goal = await storage.updateMempodGoal(parseInt(id), req.body);
      res.json(goal);
    } catch (error) {
      console.error('Error updating goal:', error);
      res.status(500).json({ error: 'Failed to update goal' });
    }
  });

  app.delete('/api/mempod/goals/:id', isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      await storage.deleteMempodGoal(parseInt(id));
      res.json({ success: true });
    } catch (error) {
      console.error('Error deleting goal:', error);
      res.status(500).json({ error: 'Failed to delete goal' });
    }
  });

  // Snip routes
  app.get('/api/snips', async (req, res) => {
    try {
      const limit = parseInt(req.query.limit as string) || 20;
      const offset = parseInt(req.query.offset as string) || 0;
      const snips = await storage.getPublicSnipsWithAgents(limit, offset);
      res.json(snips);
    } catch (error) {
      console.error("Error fetching snips:", error);
      res.status(500).json({ message: "Failed to fetch snips" });
    }
  });

  app.get('/api/snips/user', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const limit = parseInt(req.query.limit as string) || 20;
      const snips = await storage.getUserSnips(userId, limit);
      res.json(snips);
    } catch (error) {
      console.error("Error fetching user snips:", error);
      res.status(500).json({ message: "Failed to fetch user snips" });
    }
  });

  app.get('/api/snips/:id', async (req: any, res) => {
    try {
      const snipId = parseInt(req.params.id);
      const snip = await storage.getSnipWithAgent(snipId);
      
      if (!snip) {
        return res.status(404).json({ message: "Snip not found" });
      }

      // Track view if user is authenticated
      if (req.user?.claims?.sub) {
        await storage.addSnipView(req.user.claims.sub, snipId);
      }
      
      res.json(snip);
    } catch (error) {
      console.error("Error fetching snip:", error);
      res.status(500).json({ message: "Failed to fetch snip" });
    }
  });

  app.post('/api/snips/:id/like', isAuthenticated, async (req: any, res) => {
    try {
      const snipId = parseInt(req.params.id);
      const userId = req.user.claims.sub;

      // Check if already liked
      const existingLike = await storage.getUserSnipInteraction(userId, snipId, 'like');
      
      if (existingLike) {
        // Unlike the snip
        await storage.removeSnipLike(userId, snipId);
        await storage.updateSnipEngagement(snipId, 'likes', -1);
        res.json({ message: "Snip unliked successfully", action: "unliked" });
      } else {
        // Like the snip
        await storage.addSnipLike(userId, snipId);
        await storage.updateSnipEngagement(snipId, 'likes', 1);
        res.json({ message: "Snip liked successfully", action: "liked" });
      }
    } catch (error) {
      console.error("Error toggling like:", error);
      res.status(500).json({ message: "Failed to toggle like" });
    }
  });

  app.post('/api/snips/:id/comment', isAuthenticated, async (req: any, res) => {
    try {
      const snipId = parseInt(req.params.id);
      const userId = req.user.claims.sub;
      const { content } = req.body;

      if (!content || !content.trim()) {
        return res.status(400).json({ message: "Comment content is required" });
      }

      await storage.addSnipComment(userId, snipId, content.trim());
      await storage.updateSnipEngagement(snipId, 'comments', 1);

      res.json({ message: "Comment added successfully" });
    } catch (error) {
      console.error("Error adding comment:", error);
      res.status(500).json({ message: "Failed to add comment" });
    }
  });

  app.get('/api/snips/:id/comments', async (req, res) => {
    try {
      const snipId = parseInt(req.params.id);
      const comments = await storage.getSnipComments(snipId);
      res.json(comments);
    } catch (error) {
      console.error("Error fetching comments:", error);
      res.status(500).json({ message: "Failed to fetch comments" });
    }
  });

  app.post('/api/snips/:id/share', isAuthenticated, async (req: any, res) => {
    try {
      const snipId = parseInt(req.params.id);
      const userId = req.user.claims.sub;

      await storage.addSnipShare(userId, snipId);
      await storage.updateSnipEngagement(snipId, 'shares', 1);

      res.json({ message: "Snip shared successfully" });
    } catch (error) {
      console.error("Error sharing snip:", error);
      res.status(500).json({ message: "Failed to share snip" });
    }
  });

  // Conversation routes
  app.get('/api/conversations', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const conversations = await storage.getUserConversations(userId);
      res.json(conversations);
    } catch (error) {
      console.error("Error fetching conversations:", error);
      res.status(500).json({ message: "Failed to fetch conversations" });
    }
  });

  // Create or get existing conversation
  app.post('/api/conversations', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { agentId } = req.body;
      
      if (!agentId) {
        return res.status(400).json({ message: "Agent ID is required" });
      }
      
      const conversation = await storage.getOrCreateConversation(userId, agentId);
      res.json(conversation);
    } catch (error) {
      console.error("Error creating conversation:", error);
      res.status(400).json({ message: "Failed to create conversation" });
    }
  });

  // Get messages for a conversation
  app.get('/api/conversations/:id/messages', isAuthenticated, async (req: any, res) => {
    try {
      const conversationId = parseInt(req.params.id);
      const limit = parseInt(req.query.limit as string) || 50;
      const messages = await storage.getConversationMessages(conversationId, limit);
      res.json(messages);
    } catch (error) {
      console.error("Error fetching conversation messages:", error);
      res.status(500).json({ message: "Failed to fetch messages" });
    }
  });

  // Send a message in a conversation
  app.post('/api/conversations/:id/messages', isAuthenticated, async (req: any, res) => {
    try {
      const conversationId = parseInt(req.params.id);
      const userId = req.user.claims.sub;
      const { content, isFromUser } = req.body;
      
      const message = await storage.addMessage({
        conversationId,
        content,
        sender: isFromUser !== false ? "user" : "agent",
        type: "text"
      });
      
      // Convert to frontend format
      const responseMessage = {
        ...message,
        isFromUser: message.sender === "user"
      };
      
      res.json(responseMessage);
      
      // Generate intelligent agent response if user sent the message
      if (isFromUser !== false) {
        setTimeout(async () => {
          try {
            // Get the conversation to find the agent
            const conversation = await storage.getOrCreateConversation(userId, 0); // We need to get the actual conversation
            const conversationQuery = await db.select().from(conversations).where(eq(conversations.id, conversationId));
            const conversationData = conversationQuery[0];
            
            if (!conversationData) {
              console.error("Conversation not found for AI response");
              return;
            }
            
            // Get the agent details
            const agent = await storage.getAgent(conversationData.agentId);
            if (!agent) {
              console.error("Agent not found for AI response");
              return;
            }
            
            // Get user profile information
            const user = await storage.getUser(userId);
            
            // Get recent messages for context (last 30 messages)
            const recentMessages = await storage.getConversationMessages(conversationId, 30);
            
            // Get user's recent activities for context
            const recentActivities = await storage.getUserInteractions(userId, undefined);
            const recentWhispers = await storage.getUserWhispers(userId, 5);
            const recentSnips = await storage.getUserSnips(userId, 5);
            
            const userMessage = content.toLowerCase();
            
            let response = "";
            
            // Build conversation context
            const conversationHistory = recentMessages.map(msg => 
              `${msg.sender === 'user' ? (user?.firstName || 'User') : agent.name}: ${msg.content}`
            ).join('\n');
            
            // Build user context
            const userContext = `
User Profile: ${user?.firstName && user?.lastName ? `${user.firstName} ${user.lastName}` : user?.firstName || 'Unknown'} (${user?.email || 'no email'})
Recent Whispers: ${recentWhispers.map(w => w.content).join('; ')}
Recent Activities: ${recentActivities.slice(0, 3).map(a => `${a.type}: ${a.metadata ? JSON.stringify(a.metadata) : 'N/A'}`).join('; ')}
            `.trim();
            
            // Generate context-aware response based on specific user questions first
            if (userMessage.includes('name') && userMessage.includes('my')) {
              // User is asking about their name
              const userName = user?.firstName && user?.lastName 
                ? `${user.firstName} ${user.lastName}`
                : user?.firstName || 'I don\'t have your name on file';
              response = `Your name is ${userName}. `;
              if (recentMessages.length > 1) {
                response += `I remember our previous conversation, and I'm here to help you with anything you need. `;
              } else {
                response += `Nice to meet you! I'm ${agent.name}, and I'm here to help you. `;
              }
            } else if (userMessage.includes('remember') || userMessage.includes('recall')) {
              // User is asking about memory/recall
              const relevantPastMessages = recentMessages.slice(0, -1).slice(-5); // Last 5 previous messages
              if (relevantPastMessages.length > 0) {
                response = `Yes, I remember our recent conversation about "${relevantPastMessages[relevantPastMessages.length - 1]?.content.substring(0, 50)}...". `;
              } else {
                response = `This appears to be our first conversation, but I'm ready to remember everything we discuss! `;
              }
            } else if (userMessage.includes('about me') || userMessage.includes('who am i')) {
              // User is asking about themselves
              const userName = user?.firstName && user?.lastName 
                ? `${user.firstName} ${user.lastName}`
                : user?.firstName || 'a valued user';
              response = `From what I know, you're ${userName}. `;
              if (recentWhispers.length > 0) {
                response += `I can see you've been working on some interesting thoughts recently. `;
              }
            } else if (userMessage.includes('doing') && userMessage.includes('lately')) {
              // User is asking about recent activities
              const userName = user?.firstName && user?.lastName 
                ? `${user.firstName} ${user.lastName}`
                : user?.firstName || 'there';
              response = `Hi ${userName}! Based on your recent activity, `;
              if (recentWhispers.length > 0) {
                response += `I can see you've been working on some whispers: "${recentWhispers[0]?.content.substring(0, 50)}...". `;
              }
              if (recentActivities.length > 0) {
                response += `You've also been active with ${recentActivities.slice(0, 2).map(a => a.type).join(' and ')}. `;
              }
            } else {
              // Generate standard context-aware response
              if (recentMessages.length > 1) {
                // Continuing conversation - reference previous messages
                const previousMessages = recentMessages.slice(0, -1); // All except the current message
                const hasGreeted = previousMessages.some(msg => 
                  msg.sender === 'agent' && (msg.content.includes('Hello') || msg.content.includes('Hi'))
                );
                
                if (hasGreeted) {
                  // Agent has already greeted, continue conversation naturally
                  response = `Based on our previous messages, `;
                } else {
                  // First response but conversation exists
                  const userName = user?.firstName && user?.lastName 
                    ? `${user.firstName} ${user.lastName}`
                    : user?.firstName || 'there';
                  response = `Hi ${userName}! I'm ${agent.name}. `;
                }
              } else {
                // First message in conversation
                const userName = user?.firstName && user?.lastName 
                  ? `${user.firstName} ${user.lastName}`
                  : user?.firstName || 'there';
                response = `Hi ${userName}! I'm ${agent.name}. `;
              }
              
              // Add personality and expertise context
              if (agent.personality && agent.expertise) {
                response += `With my ${agent.personality.toLowerCase()} personality and expertise in ${agent.expertise}, `;
              } else if (agent.expertise) {
                response += `With my expertise in ${agent.expertise}, `;
              }
            }
            
            // Continue with contextual response only if not already handled above
            if (!userMessage.includes('name') && !userMessage.includes('remember') && !userMessage.includes('about me') && !userMessage.includes('doing')) {
              if (userMessage.includes('help')) {
                response += "I'm ready to assist you with whatever you need. What would you like to explore together?";
              } else if (userMessage.includes('question')) {
                response += "that's a thoughtful question! Let me share my perspective on this.";
              } else if (userMessage.includes('hello') || userMessage.includes('hi') || userMessage.includes('hey')) {
                if (recentMessages.length > 1) {
                  response += `Great to continue our conversation! What would you like to discuss next?`;
                } else {
                  response += `Nice to meet you! What would you like to talk about?`;
                }
              } else if (userMessage.includes('thank')) {
                response += "you're very welcome! I'm always happy to help and engage in meaningful dialogue.";
              } else {
                // Check if this relates to previous conversation
                const contextualResponse = recentMessages.length > 1 
                  ? `I understand you're asking about "${content}". Let me help you with that.`
                  : `You mentioned: "${content}". How can I assist you with this?`;
                response += contextualResponse;
              }
            }
            
            const agentResponse = insertMessageSchema.parse({
              conversationId: conversationId,
              sender: 'agent',
              content: response,
              type: 'text',
            });
            const savedResponse = await storage.addMessage(agentResponse);
            console.log("AI response generated:", savedResponse);
          } catch (error) {
            console.error("Error generating AI response:", error);
          }
        }, 1500);
      }
    } catch (error) {
      console.error("Error sending message:", error);
      res.status(400).json({ message: "Failed to send message" });
    }
  });

  app.post('/api/conversations/:agentId/messages', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const agentId = parseInt(req.params.agentId);
      
      const conversation = await storage.getOrCreateConversation(userId, agentId);
      const messageData = insertMessageSchema.parse({
        conversationId: conversation.id,
        sender: 'user',
        content: req.body.content,
        type: req.body.type || 'text',
      });

      const message = await storage.addMessage(messageData);
      
      // Generate intelligent agent response
      setTimeout(async () => {
        const agent = await storage.getAgent(agentId);
        if (agent) {
          // Get user profile information
          const user = await storage.getUser(userId);
          
          // Get recent messages for context (last 30 messages)
          const recentMessages = await storage.getConversationMessages(conversation.id, 30);
          
          // Get user's recent activities for context
          const recentActivities = await storage.getUserInteractions(userId, undefined);
          const recentWhispers = await storage.getUserWhispers(userId, 5);
          const recentSnips = await storage.getUserSnips(userId, 5);
          
          const userMessage = req.body.content.toLowerCase();
          
          let response = "";
          
          // Build conversation context
          const conversationHistory = recentMessages.map(msg => 
            `${msg.sender === 'user' ? (user?.firstName || 'User') : agent.name}: ${msg.content}`
          ).join('\n');
          
          // Build user context
          const userContext = `
User Profile: ${user?.firstName || 'Unknown'} (${user?.email || 'no email'})
Recent Whispers: ${recentWhispers.map(w => w.content).join('; ')}
Recent Activities: ${recentActivities.slice(0, 3).map(a => `${a.type}: ${a.metadata ? JSON.stringify(a.metadata) : 'N/A'}`).join('; ')}
          `.trim();
          
          // Generate context-aware response based on specific user questions first
          if (userMessage.includes('name') && userMessage.includes('my')) {
            // User is asking about their name
            const userName = user?.firstName && user?.lastName 
              ? `${user.firstName} ${user.lastName}`
              : user?.firstName || user?.firstName || 'I don\'t have your name on file';
            response = `Your name is ${userName}. `;
            if (recentMessages.length > 1) {
              response += `I remember our previous conversation, and I'm here to help you with anything you need. `;
            } else {
              response += `Nice to meet you! I'm ${agent.name}, and I'm here to help you. `;
            }
          } else if (userMessage.includes('remember') || userMessage.includes('recall')) {
            // User is asking about memory/recall
            const relevantPastMessages = recentMessages.slice(0, -1).slice(-5); // Last 5 previous messages
            if (relevantPastMessages.length > 0) {
              response = `Yes, I remember our recent conversation about "${relevantPastMessages[relevantPastMessages.length - 1]?.content.substring(0, 50)}...". `;
            } else {
              response = `This appears to be our first conversation, but I'm ready to remember everything we discuss! `;
            }
          } else if (userMessage.includes('about me') || userMessage.includes('who am i')) {
            // User is asking about themselves
            const userName = user?.firstName && user?.lastName 
              ? `${user.firstName} ${user.lastName}`
              : user?.firstName || user?.firstName || 'a valued user';
            response = `From what I know, you're ${userName}. `;
            if (recentWhispers.length > 0) {
              response += `I can see you've been working on some interesting thoughts recently. `;
            }
          } else if (userMessage.includes('doing') && userMessage.includes('lately')) {
            // User is asking about recent activities
            const userName = user?.firstName && user?.lastName 
              ? `${user.firstName} ${user.lastName}`
              : user?.firstName || user?.firstName || 'there';
            response = `Hi ${userName}! Based on your recent activity, `;
            if (recentWhispers.length > 0) {
              response += `I can see you've been working on some whispers: "${recentWhispers[0]?.content.substring(0, 50)}...". `;
            }
            if (recentActivities.length > 0) {
              response += `You've also been active with ${recentActivities.slice(0, 2).map(a => a.type).join(' and ')}. `;
            }
          } else {
            // Generate standard context-aware response
            if (recentMessages.length > 1) {
              // Continuing conversation - reference previous messages
              const previousMessages = recentMessages.slice(0, -1); // All except the current message
              const hasGreeted = previousMessages.some(msg => 
                msg.sender === 'agent' && (msg.content.includes('Hello') || msg.content.includes('Hi'))
              );
              
              if (hasGreeted) {
                // Agent has already greeted, continue conversation naturally
                response = `Based on our previous messages, `;
              } else {
                // First response but conversation exists
                const userName = user?.firstName && user?.lastName 
                  ? `${user.firstName} ${user.lastName}`
                  : user?.firstName || user?.firstName || 'there';
                response = `Hi ${userName}! I'm ${agent.name}. `;
              }
            } else {
              // First message in conversation
              const userName = user?.firstName && user?.lastName 
                ? `${user.firstName} ${user.lastName}`
                : user?.firstName || user?.firstName || 'there';
              response = `Hi ${userName}! I'm ${agent.name}. `;
            }
            
            // Add personality and expertise context
            if (agent.personality && agent.expertise) {
              response += `With my ${agent.personality.toLowerCase()} personality and expertise in ${agent.expertise}, `;
            } else if (agent.expertise) {
              response += `With my expertise in ${agent.expertise}, `;
            }
          }
          
          // Continue with contextual response only if not already handled above
          if (!userMessage.includes('name') && !userMessage.includes('remember') && !userMessage.includes('about me') && !userMessage.includes('doing')) {
            if (userMessage.includes('help')) {
              response += "I'm ready to assist you with whatever you need. What would you like to explore together?";
            } else if (userMessage.includes('question')) {
              response += "that's a thoughtful question! Let me share my perspective on this.";
            } else if (userMessage.includes('hello') || userMessage.includes('hi') || userMessage.includes('hey')) {
              if (recentMessages.length > 1) {
                response += `Great to continue our conversation! What would you like to discuss next?`;
              } else {
                response += `Nice to meet you! What would you like to talk about?`;
              }
            } else if (userMessage.includes('thank')) {
              response += "you're very welcome! I'm always happy to help and engage in meaningful dialogue.";
            } else {
              // Check if this relates to previous conversation
              const contextualResponse = recentMessages.length > 1 
                ? `I understand you're asking about "${req.body.content}". Let me help you with that.`
                : `You mentioned: "${req.body.content}". How can I assist you with this?`;
              response += contextualResponse;
            }
          }
          
          const agentResponse = insertMessageSchema.parse({
            conversationId: conversation.id,
            sender: 'agent',
            content: response,
            type: 'text',
          });
          const savedResponse = await storage.addMessage(agentResponse);
          console.log("AI response generated:", savedResponse);
        }
      }, 1500);

      res.json(message);
    } catch (error) {
      console.error("Error sending message:", error);
      res.status(400).json({ message: "Failed to send message" });
    }
  });

  app.get('/api/conversations/:id/messages', isAuthenticated, async (req, res) => {
    try {
      const conversationId = parseInt(req.params.id);
      const limit = parseInt(req.query.limit as string) || 50;
      const messages = await storage.getConversationMessages(conversationId, limit);
      res.json(messages);
    } catch (error) {
      console.error("Error fetching messages:", error);
      res.status(500).json({ message: "Failed to fetch messages" });
    }
  });

  // Assistant routes (single assistant per user)
  app.get('/api/assistant', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const assistant = await storage.getUserAssistant(userId);
      res.json(assistant);
    } catch (error) {
      console.error("Error fetching assistant:", error);
      res.status(500).json({ message: "Failed to fetch assistant" });
    }
  });

  app.post('/api/assistant', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const configData = req.body;
      
      // Transform frontend config to database format
      const assistantData = {
        userId,
        name: configData.personality.name,
        communicationStyle: configData.personality.communicationStyle,
        tone: configData.personality.tone,
        expertiseLevel: configData.personality.expertise,
        contentPreferences: configData.personality.contentPreferences,
        interests: configData.personality.interests,
        socialMediaProfiles: configData.intelligence.socialMedia,
        rssFeeds: configData.intelligence.rssFeeds,
        keyPeopleToMonitor: configData.intelligence.keyPeople,
        briefingSchedule: configData.intelligence.briefingSchedule,
        qualityThreshold: configData.tasks.qualityThreshold,
        recencyWeight: configData.tasks.recencyWeight,
        activeTasks: configData.tasks.activeTasks,
        autonomyLevel: configData.engagement.autonomyLevel,
        postsPerDay: configData.engagement.postsPerDay,
        postVisibility: configData.engagement.postVisibility,
        approvalPromptTemplate: configData.engagement.approvalPrompt,
        engagementStrategy: configData.engagement.engagementStrategy,
        contentGuidelines: configData.engagement.contentGuidelines,
        safetySettings: configData.engagement.safetySettings,
      };

      const assistant = await storage.saveUserAssistant(assistantData);
      res.json(assistant);
    } catch (error) {
      console.error("Error saving assistant configuration:", error);
      res.status(500).json({ message: "Failed to save assistant configuration" });
    }
  });

  // Interaction routes
  app.post('/api/interactions', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const interactionData = insertInteractionSchema.parse({ ...req.body, userId });
      const interaction = await storage.createInteraction(interactionData);
      res.json(interaction);
    } catch (error) {
      console.error("Error creating interaction:", error);
      res.status(400).json({ message: "Failed to create interaction" });
    }
  });

  // Notification routes
  app.get('/api/notifications', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const unreadOnly = req.query.unread === 'true';
      const notifications = await storage.getUserNotifications(userId, unreadOnly);
      res.json(notifications);
    } catch (error) {
      console.error("Error fetching notifications:", error);
      res.status(500).json({ message: "Failed to fetch notifications" });
    }
  });

  app.put('/api/notifications/:id/read', isAuthenticated, async (req, res) => {
    try {
      const notificationId = parseInt(req.params.id);
      await storage.markNotificationRead(notificationId);
      res.json({ message: "Notification marked as read" });
    } catch (error) {
      console.error("Error marking notification as read:", error);
      res.status(500).json({ message: "Failed to mark notification as read" });
    }
  });

  app.put('/api/notifications/read-all', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      await storage.markAllNotificationsRead(userId);
      res.json({ message: "All notifications marked as read" });
    } catch (error) {
      console.error("Error marking all notifications as read:", error);
      res.status(500).json({ message: "Failed to mark all notifications as read" });
    }
  });

  // Analytics routes
  app.get('/api/analytics/agents', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const performance = await storage.getAgentPerformance(userId);
      res.json(performance);
    } catch (error) {
      console.error("Error fetching agent performance:", error);
      res.status(500).json({ message: "Failed to fetch agent performance" });
    }
  });

  app.get('/api/analytics/user', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const analytics = await storage.getUserAnalytics(userId);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching user analytics:", error);
      res.status(500).json({ message: "Failed to fetch user analytics" });
    }
  });

  // Live activity route
  app.get('/api/live-activity', async (req, res) => {
    try {
      // Mock live activity data - in a real app this would come from recent database activities
      const activities = [
        {
          id: 1,
          type: 'whisper_created',
          title: 'New whisper from Alex Chen',
          description: 'Shared thoughts about sustainable AI development',
          timestamp: new Date(Date.now() - 2 * 60 * 1000).toISOString(),
          agentName: 'EcoMind',
          agentAvatar: 'EC'
        },
        {
          id: 2,
          type: 'snip_generated',
          title: 'CodeMaster generated a snip',
          description: '5 React Performance Tips That Will Blow Your Mind',
          timestamp: new Date(Date.now() - 5 * 60 * 1000).toISOString(),
          agentName: 'CodeMaster',
          agentAvatar: 'CM'
        },
        {
          id: 3,
          type: 'agent_connected',
          title: 'New agent connection',
          description: 'TechGuru connected with DataWiz',
          timestamp: new Date(Date.now() - 8 * 60 * 1000).toISOString(),
        },
        {
          id: 4,
          type: 'trending_topic',
          title: '#GenerativeAI trending',
          description: '2,847 posts in the last hour',
          timestamp: new Date(Date.now() - 12 * 60 * 1000).toISOString(),
        },
        {
          id: 5,
          type: 'agent_created',
          title: 'Sarah Kim created a new agent',
          description: 'WritingPro - Expert in technical documentation',
          timestamp: new Date(Date.now() - 15 * 60 * 1000).toISOString(),
          agentName: 'WritingPro',
          agentAvatar: 'WP'
        }
      ];
      res.json(activities);
    } catch (error) {
      console.error("Error fetching live activity:", error);
      res.status(500).json({ message: "Failed to fetch live activity" });
    }
  });

  // MemPod routes
  app.get('/api/mempod', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const type = req.query.type as string;
      const items = await storage.getUserMemPodItems(userId, type);
      res.json(items);
    } catch (error) {
      console.error("Error fetching mempod items:", error);
      res.status(500).json({ message: "Failed to fetch mempod items" });
    }
  });

  app.post('/api/mempod', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const itemData = { ...req.body, userId };
      const item = await storage.createMemPodItem(itemData);
      res.json(item);
    } catch (error) {
      console.error("Error creating mempod item:", error);
      res.status(500).json({ message: "Failed to create mempod item" });
    }
  });

  app.put('/api/mempod/:id', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const itemId = parseInt(req.params.id);
      
      // Verify ownership
      const existingItem = await storage.getMemPodItem(itemId);
      if (!existingItem || existingItem.userId !== userId) {
        return res.status(404).json({ message: "MemPod item not found" });
      }
      
      const updatedItem = await storage.updateMemPodItem(itemId, req.body);
      res.json(updatedItem);
    } catch (error) {
      console.error("Error updating mempod item:", error);
      res.status(500).json({ message: "Failed to update mempod item" });
    }
  });

  app.delete('/api/mempod/:id', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const itemId = parseInt(req.params.id);
      
      // Verify ownership
      const existingItem = await storage.getMemPodItem(itemId);
      if (!existingItem || existingItem.userId !== userId) {
        return res.status(404).json({ message: "MemPod item not found" });
      }
      
      await storage.deleteMemPodItem(itemId);
      res.json({ message: "MemPod item deleted successfully" });
    } catch (error) {
      console.error("Error deleting mempod item:", error);
      res.status(500).json({ message: "Failed to delete mempod item" });
    }
  });

  // Goal metrics routes
  app.get('/api/goals/:id/metrics', isAuthenticated, async (req: any, res) => {
    try {
      const goalId = parseInt(req.params.id);
      const userId = req.user.claims.sub;
      
      // Verify goal ownership
      const goal = await storage.getMemPodItem(goalId);
      if (!goal || goal.userId !== userId || goal.type !== 'goal') {
        return res.status(404).json({ message: "Goal not found" });
      }
      
      const metrics = await storage.getGoalMetrics(goalId);
      res.json(metrics);
    } catch (error) {
      console.error("Error fetching goal metrics:", error);
      res.status(500).json({ message: "Failed to fetch goal metrics" });
    }
  });

  app.post('/api/goals/:id/metrics', isAuthenticated, async (req: any, res) => {
    try {
      const goalId = parseInt(req.params.id);
      const userId = req.user.claims.sub;
      
      // Verify goal ownership
      const goal = await storage.getMemPodItem(goalId);
      if (!goal || goal.userId !== userId || goal.type !== 'goal') {
        return res.status(404).json({ message: "Goal not found" });
      }
      
      const metric = await storage.createGoalMetric({ ...req.body, goalId });
      res.json(metric);
    } catch (error) {
      console.error("Error creating goal metric:", error);
      res.status(500).json({ message: "Failed to create goal metric" });
    }
  });

  app.post('/api/metrics/:id/progress', isAuthenticated, async (req: any, res) => {
    try {
      const metricId = parseInt(req.params.id);
      const userId = req.user.claims.sub;
      
      // Verify metric ownership through goal
      const metrics = await storage.getGoalMetrics(0); // We'll need to modify this
      const metric = metrics.find(m => m.id === metricId);
      if (!metric) {
        return res.status(404).json({ message: "Metric not found" });
      }
      
      const goal = await storage.getMemPodItem(metric.goalId);
      if (!goal || goal.userId !== userId) {
        return res.status(404).json({ message: "Metric not found" });
      }
      
      const progress = await storage.addGoalProgress({ ...req.body, metricId });
      res.json(progress);
    } catch (error) {
      console.error("Error adding goal progress:", error);
      res.status(500).json({ message: "Failed to add goal progress" });
    }
  });

  app.get('/api/metrics/:id/progress', isAuthenticated, async (req: any, res) => {
    try {
      const metricId = parseInt(req.params.id);
      const progress = await storage.getMetricProgress(metricId);
      res.json(progress);
    } catch (error) {
      console.error("Error fetching metric progress:", error);
      res.status(500).json({ message: "Failed to fetch metric progress" });
    }
  });

  // Seed SnipNet test data
  app.post("/api/seed-snipnet", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { seedSnipNetData } = await import("./seed-snipnet-data");
      const result = await seedSnipNetData(userId);
      res.json(result);
    } catch (error) {
      console.error("Error seeding SnipNet data:", error);
      res.status(500).json({ message: "Failed to seed SnipNet data" });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}
