<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SnipNet - Interactive Thought Resonance Map</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Deep purple background */
            color: #ffffff;
            overflow: hidden;
        }
        #snipnet-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
        }
        #controls {
            z-index: 10;
            padding: 1rem;
            background-color: rgba(26, 26, 46, 0.8);
            backdrop-filter: blur(5px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        #snipnet-svg {
            flex-grow: 1;
            width: 100%;
            cursor: grab;
        }
        .node-circle {
            stroke: #fff;
            stroke-width: 1.5px;
            cursor: pointer;
            transition: r 0.2s ease-in-out;
        }
        .node-circle:hover {
            r: 12;
            stroke-width: 3px;
        }
        .link {
            stroke: #4a4e6e;
            stroke-opacity: 0.6;
            stroke-width: 1px;
            transition: stroke 0.2s ease-in-out;
        }
        .link.active {
            stroke: #e94560;
            stroke-width: 2px;
            animation: pulse 1s infinite alternate;
        }
        @keyframes pulse {
            from { stroke-opacity: 0.6; }
            to { stroke-opacity: 1; }
        }
        .tooltip {
            position: absolute;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            padding: 10px;
            max-width: 300px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            color: white;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-radius: 50%;
            border-top: 4px solid #3498db;
            width: 24px;
            height: 24px;
            -webkit-animation: spin 2s linear infinite;
            animation: spin 2s linear infinite;
        }
        @-webkit-keyframes spin {
            0% { -webkit-transform: rotate(0deg); }
            100% { -webkit-transform: rotate(360deg); }
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="snipnet-container" class="bg-[#1a1a2e] text-white">
        <header id="controls" class="flex flex-col sm:flex-row items-center justify-between gap-4 p-4">
            <div class="flex items-center gap-4">
                <h1 class="text-3xl font-bold text-[#e94560]">SnipNet</h1>
                <p class="text-lg hidden sm:block">Explore the resonance between your ideas.</p>
            </div>
            <div class="flex flex-wrap items-center justify-center gap-2">
                <button id="back-button" class="bg-[#e94560] text-white px-4 py-2 rounded-lg font-semibold hover:bg-[#d63050] transition-colors duration-200 shadow-md hidden">Back to SnipNet</button>
                <button id="add-snip-button" class="bg-[#4a4e6e] text-white px-4 py-2 rounded-lg font-semibold hover:bg-[#6c708f] transition-colors duration-200 shadow-md">Add New Snip</button>
                <div class="relative">
                    <button id="filter-button" class="bg-[#4a4e6e] text-white px-4 py-2 rounded-lg font-semibold hover:bg-[#6c708f] transition-colors duration-200 shadow-md">Filter by Cluster</button>
                    <div id="filter-dropdown" class="absolute top-full left-0 mt-2 bg-gray-800 rounded-md shadow-lg z-20 hidden">
                        <!-- Dropdown content will be dynamically generated -->
                    </div>
                </div>
            </div>
        </header>

        <main class="relative flex-grow">
            <svg id="snipnet-svg" class="w-full h-full"></svg>
            <div id="tooltip" class="tooltip"></div>
            <div id="modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden">
                <div class="bg-gray-900 p-8 rounded-xl shadow-2xl w-11/12 md:w-1/2 lg:w-1/3">
                    <h2 id="modal-title" class="text-2xl font-bold text-[#e94560] mb-4">Add a New Snip</h2>
                    <form id="add-snip-form" class="space-y-4">
                        <textarea id="snip-content" class="w-full h-32 bg-gray-800 text-white p-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-[#e94560]" placeholder="Write your new thought or idea here..."></textarea>
                        <div id="loader-container" class="flex items-center justify-end hidden">
                            <p class="mr-3 text-sm text-gray-400">Thinking...</p>
                            <div class="loader"></div>
                        </div>
                        <div class="flex justify-end gap-4">
                            <button type="button" id="close-modal-button" class="px-4 py-2 bg-gray-700 text-white rounded-lg hover:bg-gray-600 transition-colors">Cancel</button>
                            <button type="submit" id="submit-snip-button" class="px-4 py-2 bg-[#e94560] text-white rounded-lg font-semibold hover:bg-[#d63050] transition-colors">Add Snip</button>
                        </div>
                    </form>
                </div>
            </div>
        </main>
    </div>

    <!-- D3.js Library -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // Global variables
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : '';

        // Gemini API Configuration
        const geminiApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=`;
        const geminiApiKey = ""; // API key will be provided by the canvas environment

        // Force-directed graph setup
        const svg = d3.select("#snipnet-svg");
        const tooltip = d3.select("#tooltip");
        const width = window.innerWidth;
        const height = window.innerHeight;
        const color = d3.scaleOrdinal(d3.schemeCategory10);
        
        let graphData = {
            nodes: [],
            links: []
        };
        let originalGraphData = {};
        let currentClusterFilter = null;
        let simulation;

        // UI elements
        const backButton = document.getElementById('back-button');
        const addSnipButton = document.getElementById('add-snip-button');
        const addSnipForm = document.getElementById('add-snip-form');
        const modal = document.getElementById('modal');
        const closeModalButton = document.getElementById('close-modal-button');
        const loaderContainer = document.getElementById('loader-container');
        const filterButton = document.getElementById('filter-button');
        const filterDropdown = document.getElementById('filter-dropdown');
        
        const panAndZoom = d3.zoom()
            .scaleExtent([0.1, 8])
            .on("zoom", (event) => {
                svg.attr("transform", event.transform);
            });

        svg.call(panAndZoom);

        function updateSimulation(data) {
            graphData = data;
            
            const g = svg.select("g");
            g.remove();
            
            const newG = svg.append("g");
            const links = newG.append("g")
                .selectAll(".link")
                .data(graphData.links)
                .join("line")
                .attr("class", "link");

            const nodes = newG.append("g")
                .selectAll(".node-group")
                .data(graphData.nodes)
                .join("g")
                .attr("class", "node-group")
                .attr("data-cluster", d => d.cluster);

            nodes.append("circle")
                .attr("class", "node-circle")
                .attr("r", 8)
                .attr("fill", d => color(d.cluster))
                .on("mouseover", handleMouseOver)
                .on("mouseout", handleMouseOut)
                .on("click", handleNodeClick)
                .call(drag(simulation));

            nodes.append("text")
                .attr("x", 12)
                .attr("y", 3)
                .text(d => d.id)
                .attr("stroke", "white")
                .attr("stroke-width", 0.5)
                .attr("font-size", 10)
                .style("pointer-events", "none");

            simulation = d3.forceSimulation(graphData.nodes)
                .force("link", d3.forceLink(graphData.links).id(d => d.id).distance(100))
                .force("charge", d3.forceManyBody().strength(-300))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .on("tick", () => {
                    links
                        .attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);
                    nodes
                        .attr("transform", d => `translate(${d.x}, ${d.y})`);
                });

            // Set up filter dropdown
            setupFilterDropdown();
        }

        // Initialize the graph with a single group element
        svg.append("g");

        // Drag functionality
        function drag(simulation) {
            function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }
            function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }
            function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }
            return d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended);
        }

        // Tooltip functionality
        function handleMouseOver(event, d) {
            tooltip.style("opacity", 1)
                .html(`
                    <p class="font-bold text-[#e94560]">Snip: ${d.id}</p>
                    <p class="text-sm mt-1">${d.content}</p>
                    <p class="text-xs text-gray-400 mt-2">Cluster: ${d.cluster}</p>
                `)
                .style("left", (event.pageX + 15) + "px")
                .style("top", (event.pageY - 10) + "px");

            // Highlight connections
            svg.selectAll(".link").style("stroke-opacity", link => {
                if (link.source.id === d.id || link.target.id === d.id) {
                    return 1;
                }
                return 0.1;
            });
            svg.selectAll(".link").classed("active", link => link.source.id === d.id || link.target.id === d.id);
        }

        function handleMouseOut() {
            tooltip.style("opacity", 0);
            svg.selectAll(".link").style("stroke-opacity", 0.6).classed("active", false);
        }
        
        // Handle node click for "deep dive"
        function handleNodeClick(event, d) {
            backButton.style.display = 'block';

            const connectedNodeIds = new Set([d.id]);
            graphData.links.forEach(link => {
                if (link.source.id === d.id) {
                    connectedNodeIds.add(link.target.id);
                } else if (link.target.id === d.id) {
                    connectedNodeIds.add(link.source.id);
                }
            });

            svg.selectAll(".node-group").style("opacity", n => connectedNodeIds.has(n.id) ? 1 : 0.1);
            svg.selectAll(".link").style("opacity", l => (l.source.id === d.id || l.target.id === d.id) ? 1 : 0.1);
            svg.selectAll(".node-group").attr("pointer-events", n => connectedNodeIds.has(n.id) ? "auto" : "none");

            // Restart simulation on subset of nodes
            const subsetNodes = graphData.nodes.filter(n => connectedNodeIds.has(n.id));
            const subsetLinks = graphData.links.filter(l => connectedNodeIds.has(l.source.id) && connectedNodeIds.has(l.target.id));

            simulation.stop();
            simulation = d3.forceSimulation(subsetNodes)
                .force("link", d3.forceLink(subsetLinks).id(d => d.id).distance(100))
                .force("charge", d3.forceManyBody().strength(-200))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .on("tick", () => {
                    svg.selectAll(".link")
                        .attr("x1", l => l.source.x)
                        .attr("y1", l => l.source.y)
                        .attr("x2", l => l.target.x)
                        .attr("y2", l => l.target.y);
                    svg.selectAll(".node-group")
                        .attr("transform", n => `translate(${n.x}, ${n.y})`);
                });
        }

        // Back to full view
        backButton.addEventListener('click', () => {
            backButton.style.display = 'none';
            svg.selectAll(".node-group").style("opacity", 1).attr("pointer-events", "auto");
            svg.selectAll(".link").style("opacity", 0.6);
            updateSimulation(originalGraphData); // Restore original data
        });

        // Modal for adding a new snip
        addSnipButton.addEventListener('click', () => {
            modal.style.display = 'flex';
        });
        closeModalButton.addEventListener('click', () => {
            modal.style.display = 'none';
            document.getElementById('snip-content').value = '';
        });
        addSnipForm.addEventListener('submit', handleNewSnip);

        // Filter functionality
        filterButton.addEventListener('click', () => {
            filterDropdown.classList.toggle('hidden');
        });

        document.addEventListener('click', (event) => {
            if (!filterButton.contains(event.target) && !filterDropdown.contains(event.target)) {
                filterDropdown.classList.add('hidden');
            }
        });

        function setupFilterDropdown() {
            const clusters = [...new Set(originalGraphData.nodes.map(n => n.cluster))];
            filterDropdown.innerHTML = '';
            
            // "Show All" option
            const allButton = document.createElement('button');
            allButton.textContent = 'Show All';
            allButton.classList.add('block', 'w-full', 'text-left', 'px-4', 'py-2', 'hover:bg-gray-700', 'text-sm');
            allButton.addEventListener('click', () => {
                applyFilter(null);
                filterDropdown.classList.add('hidden');
            });
            filterDropdown.appendChild(allButton);

            clusters.forEach(cluster => {
                const clusterButton = document.createElement('button');
                clusterButton.textContent = cluster;
                clusterButton.classList.add('block', 'w-full', 'text-left', 'px-4', 'py-2', 'hover:bg-gray-700', 'text-sm');
                clusterButton.addEventListener('click', () => {
                    applyFilter(cluster);
                    filterDropdown.classList.add('hidden');
                });
                filterDropdown.appendChild(clusterButton);
            });
        }

        function applyFilter(cluster) {
            currentClusterFilter = cluster;
            if (cluster) {
                const filteredNodes = originalGraphData.nodes.filter(n => n.cluster === cluster);
                const filteredLinks = originalGraphData.links.filter(l => l.source.cluster === cluster && l.target.cluster === cluster);
                updateSimulation({ nodes: filteredNodes, links: filteredLinks });
            } else {
                updateSimulation(originalGraphData);
            }
        }

        // API call with exponential backoff
        async function fetchWithRetry(url, options, retries = 5, delay = 1000) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.status === 429) {
                        console.warn(`Rate limit exceeded. Retrying in ${delay / 1000}s...`);
                        await new Promise(res => setTimeout(res, delay));
                        delay *= 2; // Exponential backoff
                        continue;
                    }
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return await response.json();
                } catch (error) {
                    if (i === retries - 1) throw error;
                    console.error(`Fetch attempt failed: ${error}. Retrying...`);
                    await new Promise(res => setTimeout(res, delay));
                    delay *= 2;
                }
            }
        }

        // AI-powered clustering and linking with Gemini API
        async function getAIBasedGraphData(snips) {
            const prompt = `You are a helpful AI assistant. Given the following snips, cluster them into 3 to 5 thematic groups. Also, identify 5-10 strong connections between snips that have a similar theme or topic. Format your response as a JSON array of objects. Each object should have a 'cluster' and 'snips' property, and there should be a separate 'connections' property that is an array of objects with 'source' and 'target' snip IDs.
            
            Example Format:
            [
              {
                "cluster": "Technology & AI",
                "snips": ["snip_1", "snip_5"]
              },
              ...
              {
                "connections": [
                  { "source": "snip_1", "target": "snip_5" },
                  ...
                ]
              }
            ]

            Here are the snips:
            ${snips.map(s => `${s.id}: ${s.content}`).join('\n')}
            `;

            const payload = {
                contents: [{ role: "user", parts: [{ text: prompt }] }],
                generationConfig: {
                    responseMimeType: "application/json",
                }
            };
            
            try {
                const result = await fetchWithRetry(geminiApiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const responseText = result.candidates[0].content.parts[0].text;
                const parsedResponse = JSON.parse(responseText);
                
                const connections = parsedResponse.pop().connections;
                const clusters = parsedResponse;

                const nodesMap = new Map(snips.map(s => [s.id, { ...s }]));
                clusters.forEach(c => {
                    c.snips.forEach(snipId => {
                        if (nodesMap.has(snipId)) {
                            nodesMap.get(snipId).cluster = c.cluster;
                        }
                    });
                });

                const links = connections.map(c => ({
                    source: nodesMap.get(c.source),
                    target: nodesMap.get(c.target)
                }));
                
                // Add any missing nodes to ensure all are in the graph
                const finalNodes = Array.from(nodesMap.values());
                
                return { nodes: finalNodes, links: links };

            } catch (error) {
                console.error('Error generating AI graph data:', error);
                return { nodes: snips, links: [] };
            }
        }

        // Handle form submission for a new snip
        async function handleNewSnip(event) {
            event.preventDefault();
            const snipContent = document.getElementById('snip-content').value;
            if (!snipContent.trim()) return;

            loaderContainer.classList.remove('hidden');
            const submitButton = document.getElementById('submit-snip-button');
            submitButton.disabled = true;

            const newSnipId = `snip_${originalGraphData.nodes.length + 1}`;
            const newSnip = {
                id: newSnipId,
                content: snipContent,
                cluster: 'New Snips' // Initially assign a temporary cluster
            };
            
            // Add the new snip to the original data
            originalGraphData.nodes.push(newSnip);
            
            // Re-generate clusters and connections with AI
            try {
                const newGraphData = await getAIBasedGraphData(originalGraphData.nodes);
                originalGraphData.nodes = newGraphData.nodes;
                originalGraphData.links = newGraphData.links;
                updateSimulation(originalGraphData);
                modal.style.display = 'none';
                document.getElementById('snip-content').value = '';
            } catch (error) {
                console.error("Failed to update graph with new snip:", error);
            } finally {
                loaderContainer.classList.add('hidden');
                submitButton.disabled = false;
            }
        }

        // Initial Data to seed the graph
        const initialSnips = [
            { id: "snip_1", content: "The elegance of a well-commented code snippet. It's poetry in motion." },
            { id: "snip_2", content: "Exploring the philosophical implications of artificial consciousness. Is a digital mind still a mind?" },
            { id: "snip_3", content: "A new recipe idea: lemon and rosemary roasted chicken with a side of sweet potato mash." },
            { id: "snip_4", content: "The potential of quantum computing to revolutionize material science is truly mind-boggling." },
            { id: "snip_5", content: "Found a brilliant article on the history of neural networks and their evolution into modern deep learning." },
            { id: "snip_6", content: "Thinking about the concept of 'digital identity' and how it's shaping our social interactions." },
            { id: "snip_7", content: "Just read a fascinating book on the history of spices and their role in global trade routes." },
            { id: "snip_8", content: "The best way to organize a kitchen is with a 'zone' system: prep zone, cook zone, storage zone." },
            { id: "snip_9", content: "Could a language model ever truly understand humor? Or just mimic it flawlessly?" },
            { id: "snip_10", content: "The beauty of a perfectly executed pastry. It requires both science and art." }
        ];

        window.onload = async () => {
            // Wait for the window to load before doing any D3.js or API work
            originalGraphData = await getAIBasedGraphData(initialSnips);
            updateSimulation(originalGraphData);
        };
    </script>
</body>
</html>
